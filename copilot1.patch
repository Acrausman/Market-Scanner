diff --git a/MarketScanner.Data/Providers/PolygonMarketDataProvider.cs b/MarketScanner.Data/Providers/PolygonMarketDataProvider.cs
index de50d4ae281bf6053cf3986fbcf925eb3f87088e..8fe1bc3ade114353b215fe6b64ce179287ff9d78 100644
--- a/MarketScanner.Data/Providers/PolygonMarketDataProvider.cs
+++ b/MarketScanner.Data/Providers/PolygonMarketDataProvider.cs
@@ -1,194 +1,136 @@
-?using Flurl.Http;
+using Flurl.Http;
+using MarketScanner.Data.Models;
 using MarketScanner.Data.Providers;
 using Newtonsoft.Json.Linq;
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 using System.Threading.Tasks;
-using System.Windows.Documents;
 
 public class PolygonMarketDataProvider : IMarketDataProvider
 {
+    private static readonly TimeZoneInfo EasternTimeZone = ResolveEasternTimeZone();
+
     private readonly string _apiKey;
     private readonly bool _useAdjusted = false;
 
     public PolygonMarketDataProvider(string apiKey)
     {
         _apiKey = apiKey;
     }
 
     /// <summary>
-    /// Gets the latest 15-minute delayed price and volume for a symbol.
+    /// Gets the latest completed 15-minute bar for a symbol.
     /// </summary>
     public async Task<(double price, double volume)> GetQuoteAsync(string symbol)
     {
         try
         {
-            // Get the most recent 15-minute bar
-            var bars = await GetHistoricalBarsAsync(symbol, 30, _useAdjusted);
-            if (bars.Count > 0)
-            {
-                var lastBar = bars.Last();
+            var bars = await FetchIntradayBarsAsync(symbol, 2, _useAdjusted);
+            var lastBar = bars.LastOrDefault();
+
+            if (lastBar != null)
                 return (lastBar.Close, lastBar.Volume);
-            }
+
+            var fallback = await TryFetchLastTradeAsync(symbol);
+            if (fallback != null)
+                return fallback.Value;
+
+            var daily = await FetchDailyBarsAsync(symbol, 1, adjusted: true);
+            var dailyBar = daily.LastOrDefault();
+            if (dailyBar != null)
+                return (dailyBar.Close, dailyBar.Volume);
 
             return (double.NaN, double.NaN);
         }
-        catch
+        catch (Exception ex)
         {
+            Console.WriteLine($"[Polygon] Quote failed for {symbol}: {ex.Message}");
             return (double.NaN, double.NaN);
         }
     }
 
     /// <summary>
     /// Gets historical close prices for the symbol.
     /// </summary>
-    public async Task<List<double>> GetHistoricalClosesAsync(string symbol, int limit = 50, bool adjusted = true)
+    public async Task<List<double>> GetHistoricalClosesAsync(string symbol, int limit = 50, bool adjusted = true, BarTimeframe timeframe = BarTimeframe.Minute15)
     {
         Console.WriteLine($"[Provider] Fetching closes for {symbol}");
-        var bars = await GetHistoricalBarsAsync(symbol, limit);
+        var bars = await GetHistoricalBarsAsync(symbol, limit, adjusted, timeframe);
         Console.WriteLine($"[Provider] {symbol} -> {bars.Count} bars, last close={bars.LastOrDefault()?.Close:F2}");
         return bars.Select(b => b.Close).ToList();
     }
 
 
     /// <summary>
     /// Gets historical timestamps for the symbol.
     /// </summary>
-    public async Task<List<DateTime>> GetHistoricalTimestampsAsync(string symbol, int limit = 50, bool adjusted = true)
+    public async Task<List<DateTime>> GetHistoricalTimestampsAsync(string symbol, int limit = 50, bool adjusted = true, BarTimeframe timeframe = BarTimeframe.Minute15)
     {
-        var bars = await GetHistoricalBarsAsync(symbol, limit, _useAdjusted);
+        var bars = await GetHistoricalBarsAsync(symbol, limit, adjusted, timeframe);
         return bars.Select(b => b.Timestamp).ToList();
     }
 
     /// <summary>
-    /// Internal method to fetch historical 15-minute bars from Polygon.
+    /// Internal method to fetch historical bars from Polygon.
     /// </summary>
 
-    public async Task<List<Bar>> GetHistoricalBarsAsync(string symbol, int limit = 50, bool adjusted = true)
+    public async Task<List<Bar>> GetHistoricalBarsAsync(string symbol, int limit = 50, bool adjusted = true, BarTimeframe timeframe = BarTimeframe.Minute15)
     {
-        // ask for a little extra to have room to drop today's partial bar
-        int fetch = Math.Max(limit + 80, 120);
-
-        var to = DateTime.UtcNow;
-        var from = to.AddDays(-fetch * 2); // overshoot to cover weekends/holidays
-
-        string fromStr = from.ToString("yyyy-MM-dd");
-        string toStr = to.ToString("yyyy-MM-dd");
-
-        // ? adjusted=true ; daily ; ascending
-        /*string url = $"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/day/{fromStr}/{toStr}" +
-                     $"?adjusted=true&sort=asc&limit={fetch}&apiKey={_apiKey}";
-        */
-        string url = $"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/day/{fromStr}/{toStr}" +
-                     $"?adjusted=true&sort=asc&limit={fetch}&apiKey={_apiKey}&_={Guid.NewGuid()}";
-
-        Console.WriteLine($"[Polygon] Fetching {(adjusted ? "adjusted" : "raw")} bars for {symbol}");
-        try
+        List<Bar> bars = timeframe switch
         {
-            var response = await url.GetJsonAsync<JObject>();
-            var results = response["results"]?.ToList();
-            if (results == null || results.Count == 0)
-                return new List<Bar>();
-
-            var bars = results.Select(r =>
-            {
-                long ms = r.Value<long>("t"); // unix ms UTC
-                var tsUtc = DateTimeOffset.FromUnixTimeMilliseconds(ms).UtcDateTime;
-                double close = r.Value<double>("c");
-                double volume = r.Value<double>("v");
-
-                return new Bar
-                {
-                    Timestamp = tsUtc,
-                    Close = close,
-                    Volume = volume
-                };
-            })
-
-            .Where(b => !double.IsNaN(b.Close) && b.Close > 0)
-            .OrderBy(b => b.Timestamp)
-            .ToList();
-
-            // ?? Filter out obviously invalid or delisted data
-            if (bars.Count > 0 && bars.Average(b => b.Close) < 2)
-            {
-                Console.WriteLine($"[Polygon] Skipping {symbol} — likely stale or invalid data (avg={bars.Average(b => b.Close):F2})");
-                return new List<Bar>();
-            }
-
-            // Get ET time safely (Windows/Linux compatible)
-            // ----- ensure only completed daily bars, no “today” partials -----
-            var tz = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
-            var todayEt = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz).Date;
-            var lastEt = TimeZoneInfo.ConvertTimeFromUtc(bars[^1].Timestamp, tz).Date;
-            var marketClosed = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz).TimeOfDay >= new TimeSpan(16, 0, 0);
-
-            if (lastEt == todayEt && !marketClosed)
-            {
-                Console.WriteLine($"[Polygon] Skipping in-progress bar for {symbol}");
-                bars.RemoveAt(bars.Count - 1);
-            }
+            BarTimeframe.Day => await FetchDailyBarsAsync(symbol, limit, adjusted),
+            _ => await FetchIntradayBarsAsync(symbol, limit, adjusted)
+        };
 
-
-            // Finally trim to the requested 'limit'
-            if (bars.Count > limit)
-                bars = bars.Skip(Math.Max(0, bars.Count - limit)).ToList();
-
-            return bars;
-        }
-        catch (FlurlHttpException ex)
-        {
-            Console.WriteLine($"[Polygon] Historical bars failed for {symbol}: {ex.Message}");
-            return new List<Bar>();
-        }
+        return bars;
     }
 
-    public async Task DebugBarAlignmentAsync(string symbol, int limit = 20)
+    public async Task DebugBarAlignmentAsync(string symbol, int limit = 20, BarTimeframe timeframe = BarTimeframe.Minute15)
     {
-        var bars = await GetHistoricalBarsAsync(symbol, limit);
+        var bars = await GetHistoricalBarsAsync(symbol, limit, timeframe: timeframe);
 
-        if(bars.Count == 0)
+        if (bars.Count == 0)
         {
             Console.WriteLine($"[AlignCHeck] {symbol}: No bars returned.");
             return;
         }
 
         Console.WriteLine($"[AlignCheck] {symbol} last {bars.Count} bars:");
-        foreach(var bar in bars)
+        foreach (var bar in bars)
         {
-            var tz = TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
-            var et = TimeZoneInfo.ConvertTimeFromUtc(bar.Timestamp, tz);
+            var et = TimeZoneInfo.ConvertTimeFromUtc(bar.Timestamp, EasternTimeZone);
             Console.WriteLine($"{et:yyyy-MM-dd (ddd)} close={bar.Close:F2}");
         }
 
-        //Check specing between bars
+        //Check spacing between bars
         for (int i = 1; i < bars.Count; i++)
         {
             var delta = bars[i].Timestamp - bars[i - 1].Timestamp;
-            if(delta.TotalDays > 3)
+            if (delta.TotalDays > 3)
             {
                 Console.WriteLine($"??  Gap detected between {bars[i - 1].Timestamp:yyyy-MM-dd} and {bars[i].Timestamp:yyyy-MM-dd} ({delta.TotalDays:F1} days)");
             }
         }
 
         Console.WriteLine($"[AlignCheck] Earliest={bars.First().Timestamp:yyyy-MM-dd}, Latest={bars.Last().Timestamp:yyyy-MM-dd}");
     }
 
     public async Task<List<string>> GetAllTickersAsync()
     {
         var tickers = new List<string>();
         string? nextUrl = $"https://api.polygon.io/v3/reference/tickers" +
                           $"?market=stocks&active=true&type=CS&limit=1000&apiKey={_apiKey}";
 
         try
         {
             while (!string.IsNullOrEmpty(nextUrl))
             {
                 var response = await nextUrl.GetJsonAsync<JObject>();
                 var results = response["results"]?.ToList();
 
                 if (results != null)
                 {
                     foreach (var r in results)
                     {
@@ -231,32 +173,251 @@ public class PolygonMarketDataProvider : IMarketDataProvider
         var raw = await GetHistoricalBarsAsync(symbol, 30, adjusted: false);
 
         Console.WriteLine($"[Compare] {symbol}  adjusted={adj.Last().Close}  raw={raw.Last().Close}");
 
         for (int i = 0; i < Math.Min(adj.Count, raw.Count); i++)
         {
             double a = adj[i].Close;
             double b = raw[i].Close;
             if (Math.Abs(a - b) > 0.001)
                 Console.WriteLine($"  ??  {adj[i].Timestamp:yyyy-MM-dd}: adjusted={a}, raw={b}");
         }
     }
 
 
     public async Task DebugTickerInfo(string symbol)
     {
         string url = $"https://api.polygon.io/v3/reference/tickers/{symbol}?apiKey={_apiKey}";
         var response = await url.GetJsonAsync<JObject>();
         Console.WriteLine($"[Debug Info] {symbol}: {response["results"]?["name"]} | " +
                           $"{response["results"]?["market"]} | " +
                           $"{response["results"]?["locale"]} | " +
                           $"{response["results"]?["active"]}");
     }
 
 
-    private class HistoricalBar
+    private async Task<List<Bar>> FetchIntradayBarsAsync(string symbol, int limit, bool adjusted)
     {
-        public DateTime Timestamp { get; set; }
-        public double Close { get; set; }
-        public double Volume { get; set; }
+        int requested = Math.Max(limit + 10, (int)Math.Ceiling(limit * 1.5));
+        requested = Math.Clamp(requested, 50, 50000);
+
+        var toUtc = DateTime.UtcNow;
+        const int barsPerDay = 26; // 6.5 trading hours per day on 15-minute bars
+        int lookbackDays = Math.Max((int)Math.Ceiling(requested / (double)barsPerDay) + 2, 7);
+        var fromUtc = toUtc.AddDays(-lookbackDays);
+
+        string fromStr = fromUtc.ToString("yyyy-MM-dd'T'HH:mm:ss'Z'", CultureInfo.InvariantCulture);
+        string toStr = toUtc.ToString("yyyy-MM-dd'T'HH:mm:ss'Z'", CultureInfo.InvariantCulture);
+
+        string url = $"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/15/minute/{fromStr}/{toStr}" +
+                     $"?adjusted={(adjusted ? "true" : "false")}&sort=asc&limit={requested}&apiKey={_apiKey}&_={Guid.NewGuid()}";
+
+        Console.WriteLine($"[Polygon] Fetching {(adjusted ? "adjusted" : "raw")} 15-minute bars for {symbol}");
+
+        try
+        {
+            var response = await url.GetJsonAsync<JObject>();
+            var results = response["results"]?.ToList();
+            if (results == null || results.Count == 0)
+                return new List<Bar>();
+
+            var bars = new List<Bar>(results.Count);
+
+            foreach (var r in results)
+            {
+                long ms = r.Value<long>("t");
+                var tsUtc = DateTimeOffset.FromUnixTimeMilliseconds(ms).UtcDateTime;
+                double? close = r.Value<double?>("c");
+                double? volume = r.Value<double?>("v");
+
+                if (!close.HasValue || close.Value <= 0)
+                    continue;
+
+                bars.Add(new Bar
+                {
+                    Timestamp = tsUtc,
+                    Close = close.Value,
+                    Volume = volume ?? double.NaN
+                });
+            }
+
+            bars = bars.OrderBy(b => b.Timestamp).ToList();
+
+            DropInProgressIntradayBar(bars, TimeSpan.FromMinutes(15), symbol);
+            TrimToLimit(bars, limit);
+
+            return bars;
+        }
+        catch (FlurlHttpException ex)
+        {
+            Console.WriteLine($"[Polygon] Intraday bars failed for {symbol}: {ex.Message}");
+            return new List<Bar>();
+        }
+        catch (Exception ex)
+        {
+            Console.WriteLine($"[Polygon] Unexpected error fetching bars for {symbol}: {ex.Message}");
+            return new List<Bar>();
+        }
+    }
+
+    private async Task<List<Bar>> FetchDailyBarsAsync(string symbol, int limit, bool adjusted)
+    {
+        int requested = Math.Max(limit + 5, (int)Math.Ceiling(limit * 1.25));
+        var toUtc = DateTime.UtcNow;
+        var fromUtc = toUtc.AddDays(-Math.Max(requested * 2, 30));
+
+        string fromStr = fromUtc.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
+        string toStr = toUtc.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
+
+        string url = $"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/day/{fromStr}/{toStr}" +
+                     $"?adjusted={(adjusted ? "true" : "false")}&sort=asc&limit={requested}&apiKey={_apiKey}&_={Guid.NewGuid()}";
+
+        Console.WriteLine($"[Polygon] Fetching {(adjusted ? "adjusted" : "raw")} daily bars for {symbol}");
+
+        try
+        {
+            var response = await url.GetJsonAsync<JObject>();
+            var results = response["results"]?.ToList();
+            if (results == null || results.Count == 0)
+                return new List<Bar>();
+
+            var bars = new List<Bar>(results.Count);
+
+            foreach (var r in results)
+            {
+                long ms = r.Value<long>("t");
+                var tsUtc = DateTimeOffset.FromUnixTimeMilliseconds(ms).UtcDateTime;
+                double? close = r.Value<double?>("c");
+                double? volume = r.Value<double?>("v");
+
+                if (!close.HasValue || close.Value <= 0)
+                    continue;
+
+                bars.Add(new Bar
+                {
+                    Timestamp = tsUtc,
+                    Close = close.Value,
+                    Volume = volume ?? double.NaN
+                });
+            }
+
+            bars = bars.OrderBy(b => b.Timestamp).ToList();
+
+            DropDailyInProgressBar(bars, symbol);
+            TrimToLimit(bars, limit);
+
+            return bars;
+        }
+        catch (FlurlHttpException ex)
+        {
+            Console.WriteLine($"[Polygon] Daily bars failed for {symbol}: {ex.Message}");
+            return new List<Bar>();
+        }
+        catch (Exception ex)
+        {
+            Console.WriteLine($"[Polygon] Unexpected error fetching daily bars for {symbol}: {ex.Message}");
+            return new List<Bar>();
+        }
+    }
+
+    private static void DropInProgressIntradayBar(List<Bar> bars, TimeSpan barSpan, string symbol)
+    {
+        if (bars.Count == 0)
+            return;
+
+        var last = bars[^1];
+        if (last.Timestamp.Add(barSpan) > DateTime.UtcNow)
+        {
+            Console.WriteLine($"[Polygon] Dropping in-progress intraday bar for {symbol}");
+            bars.RemoveAt(bars.Count - 1);
+        }
+    }
+
+    private static void DropDailyInProgressBar(List<Bar> bars, string symbol)
+    {
+        if (bars.Count == 0)
+            return;
+
+        if (EasternTimeZone.Equals(TimeZoneInfo.Utc))
+            return; // Cannot determine ET, keep the bar
+
+        var lastEt = TimeZoneInfo.ConvertTimeFromUtc(bars[^1].Timestamp, EasternTimeZone);
+        var nowEt = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, EasternTimeZone);
+
+        if (lastEt.Date == nowEt.Date && nowEt.TimeOfDay < new TimeSpan(16, 0, 0))
+        {
+            Console.WriteLine($"[Polygon] Dropping in-progress daily bar for {symbol}");
+            bars.RemoveAt(bars.Count - 1);
+        }
+    }
+
+    private static void TrimToLimit(List<Bar> bars, int limit)
+    {
+        if (limit <= 0)
+        {
+            bars.Clear();
+            return;
+        }
+
+        if (bars.Count <= limit)
+            return;
+
+        int removeCount = bars.Count - limit;
+        bars.RemoveRange(0, removeCount);
+    }
+
+    private static TimeZoneInfo ResolveEasternTimeZone()
+    {
+        try
+        {
+            return TimeZoneInfo.FindSystemTimeZoneById("Eastern Standard Time");
+        }
+        catch (TimeZoneNotFoundException)
+        {
+            try
+            {
+                return TimeZoneInfo.FindSystemTimeZoneById("America/New_York");
+            }
+            catch (Exception ex) when (ex is TimeZoneNotFoundException or InvalidTimeZoneException)
+            {
+                Console.WriteLine($"[Polygon] Eastern timezone unavailable ({ex.Message}); falling back to UTC");
+                return TimeZoneInfo.Utc;
+            }
+        }
+        catch (InvalidTimeZoneException ex)
+        {
+            Console.WriteLine($"[Polygon] Eastern timezone invalid ({ex.Message}); falling back to UTC");
+            return TimeZoneInfo.Utc;
+        }
+    }
+
+    private async Task<(double price, double volume)?> TryFetchLastTradeAsync(string symbol)
+    {
+        try
+        {
+            string url = $"https://api.polygon.io/v2/last/trade/{symbol}?apiKey={_apiKey}&_={Guid.NewGuid()}";
+            var response = await url.GetJsonAsync<JObject>();
+            var result = response["results"];
+
+            if (result == null)
+                return null;
+
+            double? price = result.Value<double?>("p");
+            double? size = result.Value<double?>("s");
+
+            if (price == null)
+                return null;
+
+            return (price.Value, size ?? double.NaN);
+        }
+        catch (FlurlHttpException ex)
+        {
+            Console.WriteLine($"[Polygon] Last trade failed for {symbol}: {ex.Message}");
+            return null;
+        }
+        catch (Exception ex)
+        {
+            Console.WriteLine($"[Polygon] Unexpected last trade error for {symbol}: {ex.Message}");
+            return null;
+        }
     }
 }
